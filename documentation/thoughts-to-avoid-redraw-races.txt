It turns ot redrawing stuff while making the minimum amount of effort is quite tricky.

Currently there is a list of dirty rectangles with atomic access.
In onDraw, an UIElement is supposed to draw only in the provided list of rectangles.

Vocabulary: 
- render: process of drawing the UIElement in the depth buffer and diffuse buffer
- compositing: process of turning the result of rendering into something cute into a composited buffer
- repaint: process of putting the composited buffer on screen
- dirty: an UIElement which must be rendered again

Logical proposals towards a race-free solution:
A - Everything must get drawn as soon as possible. In WM_PAINT, one must paint something coherent.
B - UIElement can't get drawn in a rectangle without all other element in the same rectangle
C - WM_TIMER must lead to a WM_PAINT with the right invalidation area. 
  => is invalidation really necessary after all? INVESTIGATE
D - WM_PAINT must have the right repaint area, which is the union of the naturally invalidated region and the elements which are redrawn.
E - Because of host-driven parameter changes, the list of dirty rectangle can change at any time. 
  => Need for atomic read + clear of that list.
F - 2 use cases for WM_PAINT to be supported:
- direct arrival there because windows moved
- WM_TIMER see that some controls are dirty => ask for WM_PAINT

Question 1: Is C valid? Is the right area really necessary or just trigerring WM_PAINT will do it?
Answer:

Question 2: Is invalidating things inside WM_PAINT possible? 
Answer: No.

Question 3: Should WM_PAINT and WM_PAINT have the same 